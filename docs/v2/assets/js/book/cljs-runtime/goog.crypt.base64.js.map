{
"version":3,
"file":"goog.crypt.base64.js",
"lineCount":193,
"mappings":"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",
"sources":["goog/crypt/base64.js"],
"sourcesContent":["// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Base64 en/decoding. Not much to say here except that we\n * work with decoded values in arrays of bytes. By \"byte\" I mean a number\n * in [0, 255].\n *\n * @author doughtie@google.com (Gavin Doughtie)\n */\n\ngoog.provide('goog.crypt.base64');\n\ngoog.require('goog.asserts');\ngoog.require('goog.crypt');\ngoog.require('goog.string');\ngoog.require('goog.userAgent');\ngoog.require('goog.userAgent.product');\n\n/**\n * Default alphabet, shared between alphabets. Only 62 characters.\n * @private {string}\n */\ngoog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n    'abcdefghijklmnopqrstuvwxyz' +\n    '0123456789';\n\n\n/**\n * Alphabet characters for Alphabet.DEFAULT encoding.\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '+/=';\n\n\n/**\n * Alphabet characters for Alphabet.WEBSAFE_DOT_PADDING encoding.\n * The dot padding is no Internet Standard, according to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64_URL_SAFE` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_WEBSAFE =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '-_.';\n\n\n/**\n * Alphabets for Base64 encoding\n * Alphabets with no padding character are for encoding without padding.\n * About the alphabets, please refer to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * @enum {number}\n */\ngoog.crypt.base64.Alphabet = {\n  DEFAULT: 0,\n  NO_PADDING: 1,\n  WEBSAFE: 2,\n  WEBSAFE_DOT_PADDING: 3,\n  WEBSAFE_NO_PADDING: 4,\n};\n\n\n/**\n * Padding chars for Base64 encoding\n * @const {string}\n * @private\n */\ngoog.crypt.base64.paddingChars_ = '=.';\n\n\n/**\n * Check if a character is a padding character\n *\n * @param {string} char\n * @return {boolean}\n * @private\n */\ngoog.crypt.base64.isPadding_ = function(char) {\n  return goog.string.contains(goog.crypt.base64.paddingChars_, char);\n};\n\n\n// Static lookup maps, lazily populated by init_()\n\n/**\n * For each `Alphabet`, maps from bytes to characters.\n *\n * @see https://jsperf.com/char-lookups\n * @type {!Object<!goog.crypt.base64.Alphabet, !Array<string>>}\n * @private\n */\ngoog.crypt.base64.byteToCharMaps_ = {};\n\n/**\n * Maps characters to bytes.\n *\n * This map is used for all alphabets since, across alphabets, common chars\n * always map to the same byte.\n *\n * `null` indicates `init` has not yet been called.\n *\n * @type {?Object<string, number>}\n * @private\n */\ngoog.crypt.base64.charToByteMap_ = null;\n\n\n/**\n * White list of implementations with known-good native atob and btoa functions.\n * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code\n * removal in per-browser compilations.\n * @private {boolean}\n */\ngoog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO ||\n    (goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI) ||\n    goog.userAgent.OPERA;\n\n\n/**\n * Does this browser have a working btoa function?\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_ENCODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    typeof(goog.global.btoa) == 'function';\n\n\n/**\n * Does this browser have a working atob function?\n * We blacklist known-bad implementations:\n *  - IE (10+) added atob() but it does not tolerate whitespace on the input.\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_DECODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&\n     typeof(goog.global.atob) == 'function');\n\n\n/**\n * Base64-encode an array of bytes.\n *\n * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n *     value in [0, 255]) to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeByteArray = function(input, alphabet) {\n  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce\n  // size of jscompiler output, and which yields slight performance increase.\n  goog.asserts.assert(\n      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');\n\n  if (alphabet === undefined) {\n    alphabet = goog.crypt.base64.Alphabet.DEFAULT;\n  }\n\n  goog.crypt.base64.init_();\n\n  var byteToCharMap = goog.crypt.base64.byteToCharMaps_[alphabet];\n\n  var output = [];\n\n  for (var i = 0; i < input.length; i += 3) {\n    var byte1 = input[i];\n    var haveByte2 = i + 1 < input.length;\n    var byte2 = haveByte2 ? input[i + 1] : 0;\n    var haveByte3 = i + 2 < input.length;\n    var byte3 = haveByte3 ? input[i + 2] : 0;\n\n    var outByte1 = byte1 >> 2;\n    var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n    var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);\n    var outByte4 = byte3 & 0x3F;\n\n    if (!haveByte3) {\n      outByte4 = 64;\n\n      if (!haveByte2) {\n        outByte3 = 64;\n      }\n    }\n\n    output.push(\n        byteToCharMap[outByte1], byteToCharMap[outByte2],\n        byteToCharMap[outByte3] || '', byteToCharMap[outByte4] || '');\n  }\n\n  return output.join('');\n};\n\n\n/**\n * Base64-encode a string.\n *\n * @param {string} input A string to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeString = function(input, alphabet) {\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {\n    return goog.global.btoa(input);\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToByteArray(input), alphabet);\n};\n\n\n/**\n * Base64-decode a string.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeString = function(input, useCustomDecoder) {\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !useCustomDecoder) {\n    return goog.global.atob(input);\n  }\n  var output = '';\n  function pushByte(b) {\n    output += String.fromCharCode(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to an Array of numbers.\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.\n * @return {!Array<number>} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {\n  var output = [];\n  function pushByte(b) { output.push(b); }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to a Uint8Array.\n *\n * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.\n * @see http://caniuse.com/uint8array\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @return {!Uint8Array} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToUint8Array = function(input) {\n  goog.asserts.assert(\n      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher('10'),\n      'Browser does not support typed arrays');\n  var len = input.length;\n  // Approximate the length of the array needed for output.\n  // Our method varies according to the format of the input, which we can\n  // consider in three categories:\n  //   A) well-formed with proper padding\n  //   B) well-formed without any padding\n  //   C) not-well-formed, either with extra whitespace in the middle or with\n  //      extra padding characters.\n  //\n  //  In the case of (A), (length * 3 / 4) will result in an integer number of\n  //  bytes evenly divisible by 3, and we need only subtract bytes according to\n  //  the padding observed.\n  //\n  //  In the case of (B), (length * 3 / 4) will result in a non-integer number\n  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible\n  //  by 3, it's well-formed with the proper amount of padding [0 padding]).\n  //  This approximation can become exact by rounding down.\n  //\n  //  In the case of (C), the only way to get the length is to walk the full\n  //  length of the string to consider each character. This is handled by\n  //  tracking the number of bytes added to the array and using subarray to\n  //  trim the array back down to size.\n  var approxByteLength = len * 3 / 4;\n  if (approxByteLength % 3) {\n    // The string isn't complete, either because it didn't include padding, or\n    // because it has extra white space.\n    // In either case, we won't generate more bytes than are completely encoded,\n    // so rounding down is appropriate to have a buffer at least as large as\n    // output.\n    approxByteLength = Math.floor(approxByteLength);\n  } else if (goog.crypt.base64.isPadding_(input[len - 1])) {\n    // The string has a round length, and has some padding.\n    // Reduce the byte length according to the quantity of padding.\n    if (goog.crypt.base64.isPadding_(input[len - 2])) {\n      approxByteLength -= 2;\n    } else {\n      approxByteLength -= 1;\n    }\n  }\n  var output = new Uint8Array(approxByteLength);\n  var outLen = 0;\n  function pushByte(b) {\n    output[outLen++] = b;\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  // Return a subarray to handle the case that input included extra whitespace\n  // or extra padding and approxByteLength was incorrect.\n  return output.subarray(0, outLen);\n};\n\n\n/**\n * @param {string} input Input to decode.\n * @param {function(number):void} pushByte result accumulator.\n * @private\n */\ngoog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {\n  goog.crypt.base64.init_();\n\n  var nextCharIndex = 0;\n  /**\n   * @param {number} default_val Used for end-of-input.\n   * @return {number} The next 6-bit value, or the default for end-of-input.\n   */\n  function getByte(default_val) {\n    while (nextCharIndex < input.length) {\n      var ch = input.charAt(nextCharIndex++);\n      var b = goog.crypt.base64.charToByteMap_[ch];\n      if (b != null) {\n        return b;  // Common case: decoded the char.\n      }\n      if (!goog.string.isEmptyOrWhitespace(ch)) {\n        throw new Error('Unknown base64 encoding at char: ' + ch);\n      }\n      // We encountered whitespace: loop around to the next input char.\n    }\n    return default_val;  // No more input remaining.\n  }\n\n  while (true) {\n    var byte1 = getByte(-1);\n    var byte2 = getByte(0);\n    var byte3 = getByte(64);\n    var byte4 = getByte(64);\n\n    // The common case is that all four bytes are present, so if we have byte4\n    // we can skip over the truncated input special case handling.\n    if (byte4 === 64) {\n      if (byte1 === -1) {\n        return;  // Terminal case: no input left to decode.\n      }\n      // Here we know an intermediate number of bytes are missing.\n      // The defaults for byte2, byte3 and byte4 apply the inferred padding\n      // rules per the public API documentation. i.e: 1 byte\n      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield\n      // a single byte of output. (Recall that 64 corresponds the padding char).\n    }\n\n    var outByte1 = (byte1 << 2) | (byte2 >> 4);\n    pushByte(outByte1);\n\n    if (byte3 != 64) {\n      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);\n      pushByte(outByte2);\n\n      if (byte4 != 64) {\n        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;\n        pushByte(outByte3);\n      }\n    }\n  }\n};\n\n\n/**\n * Lazy static initialization function. Called before\n * accessing any of the static map variables.\n * @private\n */\ngoog.crypt.base64.init_ = function() {\n  if (goog.crypt.base64.charToByteMap_) {\n    return;\n  }\n  goog.crypt.base64.charToByteMap_ = {};\n\n  // We want quick mappings back and forth, so we precompute encoding maps.\n\n  /** @type {!Array<string>} */\n  var commonChars = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split('');\n  var specialChars = [\n    '+/=',  // DEFAULT\n    '+/',   // NO_PADDING\n    '-_=',  // WEBSAFE\n    '-_.',  // WEBSAFE_DOT_PADDING\n    '-_',   // WEBSAFE_NO_PADDING\n  ];\n\n  for (var i = 0; i < 5; i++) {\n    // `i` is each value of the `goog.crypt.base64.Alphabet` enum\n    var chars = commonChars.concat(specialChars[i].split(''));\n\n    // Sets byte-to-char map\n    goog.crypt.base64\n        .byteToCharMaps_[/** @type {!goog.crypt.base64.Alphabet} */ (i)] =\n        chars;\n\n    // Sets char-to-byte map\n    for (var j = 0; j < chars.length; j++) {\n      var char = chars[j];\n\n      var existingByte = goog.crypt.base64.charToByteMap_[char];\n      if (existingByte === undefined) {\n        goog.crypt.base64.charToByteMap_[char] = j;\n      } else {\n        goog.asserts.assert(existingByte === j);\n      }\n    }\n  }\n};\n"],
"names":["goog","provide","require","crypt","base64","DEFAULT_ALPHABET_COMMON_","ENCODED_VALS","ENCODED_VALS_WEBSAFE","Alphabet","DEFAULT","NO_PADDING","WEBSAFE","WEBSAFE_DOT_PADDING","WEBSAFE_NO_PADDING","paddingChars_","isPadding_","goog.crypt.base64.isPadding_","char","string","contains","byteToCharMaps_","charToByteMap_","ASSUME_NATIVE_SUPPORT_","userAgent","GECKO","WEBKIT","product","SAFARI","OPERA","HAS_NATIVE_ENCODE_","global","btoa","HAS_NATIVE_DECODE_","IE","atob","encodeByteArray","goog.crypt.base64.encodeByteArray","input","alphabet","asserts","assert","isArrayLike","undefined","init_","byteToCharMap","output","i","length","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","push","join","encodeString","goog.crypt.base64.encodeString","stringToByteArray","decodeString","goog.crypt.base64.decodeString","useCustomDecoder","pushByte","b","String","fromCharCode","decodeStringInternal_","decodeStringToByteArray","goog.crypt.base64.decodeStringToByteArray","opt_ignored","decodeStringToUint8Array","goog.crypt.base64.decodeStringToUint8Array","isVersionOrHigher","len","approxByteLength","Math","floor","Uint8Array","outLen","subarray","goog.crypt.base64.decodeStringInternal_","nextCharIndex","getByte","default_val","ch","charAt","isEmptyOrWhitespace","Error","byte4","goog.crypt.base64.init_","commonChars","split","specialChars","chars","concat","j","existingByte"]
}

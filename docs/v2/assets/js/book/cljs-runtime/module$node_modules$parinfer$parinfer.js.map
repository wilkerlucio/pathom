{
"version":3,
"file":"module$node_modules$parinfer$parinfer.js",
"lineCount":38,
"mappings":"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",
"sources":["node_modules/parinfer/parinfer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$parinfer$parinfer\"] = function(global,require,module,exports) {\n//\n// Parinfer 3.12.0\n//\n// Copyright 2015-2017 \u00a9 Shaun Lebron\n// MIT License\n//\n// Home Page: http://shaunlebron.github.io/parinfer/\n// GitHub: https://github.com/shaunlebron/parinfer\n//\n// For DOCUMENTATION on this file, please see `doc/code.md`.\n// Use `sync.sh` to keep the function/var links in `doc/code.md` accurate.\n//\n\n//------------------------------------------------------------------------------\n// JS Module Boilerplate\n//------------------------------------------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  }\n  else {\n    root.parinfer = factory();\n  }\n}(this, function() { // start module anonymous scope\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants / Predicates\n//------------------------------------------------------------------------------\n\n// NOTE: this is a performance hack\n// The main result object uses a lot of \"unsigned integer or null\" values.\n// Using a negative integer is faster than actual null because it cuts down on\n// type coercion overhead.\nvar UINT_NULL = -999;\n\nvar INDENT_MODE = \"INDENT_MODE\",\n    PAREN_MODE = \"PAREN_MODE\";\n\nvar BACKSLASH = '\\\\',\n    BLANK_SPACE = ' ',\n    DOUBLE_SPACE = '  ',\n    DOUBLE_QUOTE = '\"',\n    NEWLINE = '\\n',\n    SEMICOLON = ';',\n    TAB = '\\t';\n\nvar LINE_ENDING_REGEX = /\\r?\\n/;\n\nvar MATCH_PAREN = {\n  \"{\": \"}\",\n  \"}\": \"{\",\n  \"[\": \"]\",\n  \"]\": \"[\",\n  \"(\": \")\",\n  \")\": \"(\"\n};\n\n// toggle this to check the asserts during development\nvar RUN_ASSERTS = false;\n\nfunction isBoolean(x) {\n  return typeof x === 'boolean';\n}\n\nfunction isArray(x) {\n  return Array.isArray(x);\n}\n\nfunction isInteger(x) {\n  return typeof x === 'number' &&\n         isFinite(x) &&\n         Math.floor(x) === x;\n}\n\n//------------------------------------------------------------------------------\n// Options Structure\n//------------------------------------------------------------------------------\n\nfunction transformChange(change) {\n  if (!change) {\n    return undefined;\n  }\n\n  var newLines = change.newText.split(LINE_ENDING_REGEX);\n  var oldLines = change.oldText.split(LINE_ENDING_REGEX);\n\n  // single line case:\n  //     (defn foo| [])\n  //              ^ newEndX, newEndLineNo\n  //           +++\n\n  // multi line case:\n  //     (defn foo\n  //           ++++\n  //        \"docstring.\"\n  //     ++++++++++++++++\n  //       |[])\n  //     ++^ newEndX, newEndLineNo\n\n  var lastOldLineLen = oldLines[oldLines.length-1].length;\n  var lastNewLineLen = newLines[newLines.length-1].length;\n\n  var oldEndX = (oldLines.length === 1 ? change.x : 0) + lastOldLineLen;\n  var newEndX = (newLines.length === 1 ? change.x : 0) + lastNewLineLen;\n  var newEndLineNo = change.lineNo + (newLines.length-1);\n\n  return {\n    x: change.x,\n    lineNo: change.lineNo,\n    oldText: change.oldText,\n    newText: change.newText,\n\n    oldEndX: oldEndX,\n    newEndX: newEndX,\n    newEndLineNo: newEndLineNo,\n\n    lookupLineNo: newEndLineNo,\n    lookupX: newEndX\n  };\n}\n\nfunction transformChanges(changes) {\n  if (changes.length === 0) {\n    return null;\n  }\n  var lines = {};\n  var line, i, change;\n  for (i=0; i<changes.length; i++) {\n    change = transformChange(changes[i]);\n    line = lines[change.lookupLineNo];\n    if (!line) {\n      line = lines[change.lookupLineNo] = {};\n    }\n    line[change.lookupX] = change;\n  }\n  return lines;\n}\n\nfunction parseOptions(options) {\n  options = options || {};\n  return {\n    cursorX: options.cursorX,\n    cursorLine: options.cursorLine,\n    prevCursorX: options.prevCursorX,\n    prevCursorLine: options.prevCursorLine,\n    selectionStartLine: options.selectionStartLine,\n    changes: options.changes,\n    partialResult: options.partialResult,\n    forceBalance: options.forceBalance,\n    returnParens: options.returnParens\n  };\n}\n\n//------------------------------------------------------------------------------\n// Result Structure\n//------------------------------------------------------------------------------\n\n// This represents the running result. As we scan through each character\n// of a given text, we mutate this structure to update the state of our\n// system.\n\nfunction initialParenTrail() {\n  return {\n    lineNo: UINT_NULL,       // [integer] - line number of the last parsed paren trail\n    startX: UINT_NULL,       // [integer] - x position of first paren in this range\n    endX: UINT_NULL,         // [integer] - x position after the last paren in this range\n    openers: [],             // [array of stack elements] - corresponding open-paren for each close-paren in this range\n    clamped: {\n      startX: UINT_NULL,     // startX before paren trail was clamped\n      endX: UINT_NULL,       // endX before paren trail was clamped\n      openers: []            // openers that were cut out after paren trail was clamped\n    }\n  };\n}\n\nfunction getInitialResult(text, options, mode, smart) {\n\n  var result = {\n\n    mode: mode,                // [enum] - current processing mode (INDENT_MODE or PAREN_MODE)\n    smart: smart,              // [boolean] - smart mode attempts special user-friendly behavior\n\n    origText: text,            // [string] - original text\n    origCursorX: UINT_NULL,    // [integer] - original cursorX option\n    origCursorLine: UINT_NULL, // [integer] - original cursorLine option\n\n    inputLines:                // [string array] - input lines that we process line-by-line, char-by-char\n      text.split(LINE_ENDING_REGEX),\n    inputLineNo: -1,           // [integer] - the current input line number\n    inputX: -1,                // [integer] - the current input x position of the current character (ch)\n\n    lines: [],                 // [string array] - output lines (with corrected parens or indentation)\n    lineNo: -1,                // [integer] - output line number we are on\n    ch: \"\",                    // [string] - character we are processing (can be changed to indicate a replacement)\n    x: 0,                      // [integer] - output x position of the current character (ch)\n    indentX: UINT_NULL,        // [integer] - x position of the indentation point if present\n\n    parenStack: [],            // We track where we are in the Lisp tree by keeping a stack (array) of open-parens.\n                               // Stack elements are objects containing keys {ch, x, lineNo, indentDelta}\n                               // whose values are the same as those described here in this result structure.\n\n    tabStops: [],              // In Indent Mode, it is useful for editors to snap a line's indentation\n                               // to certain critical points.  Thus, we have a `tabStops` array of objects containing\n                               // keys {ch, x, lineNo, argX}, which is just the state of the `parenStack` at the cursor line.\n\n    parenTrail: initialParenTrail(), // the range of parens at the end of a line\n\n    parenTrails: [],           // [array of {lineNo, startX, endX}] - all non-empty parenTrails to be returned\n\n    returnParens: false,       // [boolean] - determines if we return `parens` described below\n    parens: [],                // [array of {lineNo, x, closer, children}] - paren tree if `returnParens` is true\n\n    cursorX: UINT_NULL,        // [integer] - x position of the cursor\n    cursorLine: UINT_NULL,     // [integer] - line number of the cursor\n    prevCursorX: UINT_NULL,    // [integer] - x position of the previous cursor\n    prevCursorLine: UINT_NULL, // [integer] - line number of the previous cursor\n\n    selectionStartLine: UINT_NULL, // [integer] - line number of the current selection starting point\n\n    changes: null,             // [object] - mapping change.key to a change object (please see `transformChange` for object structure)\n\n    isInCode: true,            // [boolean] - indicates if we are currently in \"code space\" (not string or comment)\n    isEscaping: false,         // [boolean] - indicates if the next character will be escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isEscaped: false,          // [boolean] - indicates if the current character is escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isInStr: false,            // [boolean] - indicates if we are currently inside a string\n    isInComment: false,        // [boolean] - indicates if we are currently inside a comment\n    commentX: UINT_NULL,       // [integer] - x position of the start of comment on current line (if any)\n\n    quoteDanger: false,        // [boolean] - indicates if quotes are imbalanced inside of a comment (dangerous)\n    trackingIndent: false,     // [boolean] - are we looking for the indentation point of the current line?\n    skipChar: false,           // [boolean] - should we skip the processing of the current character?\n    success: false,            // [boolean] - was the input properly formatted enough to create a valid result?\n    partialResult: false,      // [boolean] - should we return a partial result when an error occurs?\n    forceBalance: false,       // [boolean] - should indent mode aggressively enforce paren balance?\n\n    maxIndent: UINT_NULL,      // [integer] - maximum allowed indentation of subsequent lines in Paren Mode\n    indentDelta: 0,            // [integer] - how far indentation was shifted by Paren Mode\n                               //  (preserves relative indentation of nested expressions)\n\n    trackingArgTabStop: null,  // [string] - enum to track how close we are to the first-arg tabStop in a list\n                               //  For example a tabStop occurs at `bar` below:\n                               //\n                               //         `   (foo    bar`\n                               //          00011112222000  <-- state after processing char (enums below)\n                               //\n                               //         0   null    => not searching\n                               //         1   'space' => searching for next space\n                               //         2   'arg'   => searching for arg\n                               //\n                               //    (We create the tabStop when the change from 2->0 happens.)\n                               //\n\n    error: {                   // if 'success' is false, return this error to the user\n      name: null,              // [string] - Parinfer's unique name for this error\n      message: null,           // [string] - error message to display\n      lineNo: null,            // [integer] - line number of error\n      x: null,                 // [integer] - start x position of error\n      extra: {\n        name: null,\n        lineNo: null,\n        x: null\n      }\n    },\n    errorPosCache: {}          // [object] - maps error name to a potential error position\n  };\n\n  // Make sure no new properties are added to the result, for type safety.\n  // (uncomment only when debugging, since it incurs a perf penalty)\n  // Object.preventExtensions(result);\n  // Object.preventExtensions(result.parenTrail);\n\n  // merge options if they are valid\n  if (options) {\n    if (isInteger(options.cursorX))            { result.cursorX            = options.cursorX;\n                                                 result.origCursorX        = options.cursorX; }\n    if (isInteger(options.cursorLine))         { result.cursorLine         = options.cursorLine;\n                                                 result.origCursorLine     = options.cursorLine; }\n    if (isInteger(options.prevCursorX))        { result.prevCursorX        = options.prevCursorX; }\n    if (isInteger(options.prevCursorLine))     { result.prevCursorLine     = options.prevCursorLine; }\n    if (isInteger(options.selectionStartLine)) { result.selectionStartLine = options.selectionStartLine; }\n    if (isArray(options.changes))              { result.changes            = transformChanges(options.changes); }\n    if (isBoolean(options.partialResult))      { result.partialResult      = options.partialResult; }\n    if (isBoolean(options.forceBalance))       { result.forceBalance       = options.forceBalance; }\n    if (isBoolean(options.returnParens))       { result.returnParens       = options.returnParens; }\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Possible Errors\n//------------------------------------------------------------------------------\n\n// `result.error.name` is set to any of these\nvar ERROR_QUOTE_DANGER = \"quote-danger\";\nvar ERROR_EOL_BACKSLASH = \"eol-backslash\";\nvar ERROR_UNCLOSED_QUOTE = \"unclosed-quote\";\nvar ERROR_UNCLOSED_PAREN = \"unclosed-paren\";\nvar ERROR_UNMATCHED_CLOSE_PAREN = \"unmatched-close-paren\";\nvar ERROR_UNMATCHED_OPEN_PAREN = \"unmatched-open-paren\";\nvar ERROR_LEADING_CLOSE_PAREN = \"leading-close-paren\";\nvar ERROR_UNHANDLED = \"unhandled\";\n\nvar errorMessages = {};\nerrorMessages[ERROR_QUOTE_DANGER] = \"Quotes must balanced inside comment blocks.\";\nerrorMessages[ERROR_EOL_BACKSLASH] = \"Line cannot end in a hanging backslash.\";\nerrorMessages[ERROR_UNCLOSED_QUOTE] = \"String is missing a closing quote.\";\nerrorMessages[ERROR_UNCLOSED_PAREN] = \"Unclosed open-paren.\";\nerrorMessages[ERROR_UNMATCHED_CLOSE_PAREN] = \"Unmatched close-paren.\";\nerrorMessages[ERROR_UNMATCHED_OPEN_PAREN] = \"Unmatched open-paren.\";\nerrorMessages[ERROR_LEADING_CLOSE_PAREN] = \"Line cannot lead with a close-paren.\";\nerrorMessages[ERROR_UNHANDLED] = \"Unhandled error.\";\n\nfunction cacheErrorPos(result, errorName) {\n  var e = {\n    lineNo: result.lineNo,\n    x: result.x,\n    inputLineNo: result.inputLineNo,\n    inputX: result.inputX\n  };\n  result.errorPosCache[errorName] = e;\n  return e;\n}\n\nfunction error(result, name) {\n  var cache = result.errorPosCache[name];\n\n  var keyLineNo = result.partialResult ? 'lineNo' : 'inputLineNo';\n  var keyX = result.partialResult ? 'x' : 'inputX';\n\n  var e = {\n    parinferError: true,\n    name: name,\n    message: errorMessages[name],\n    lineNo: cache ? cache[keyLineNo] : result[keyLineNo],\n    x: cache ? cache[keyX] : result[keyX]\n  };\n  var opener = peek(result.parenStack, 0);\n\n  if (name === ERROR_UNMATCHED_CLOSE_PAREN) {\n    // extra error info for locating the open-paren that it should've matched\n    cache = result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n    if (cache || opener) {\n      e.extra = {\n        name: ERROR_UNMATCHED_OPEN_PAREN,\n        lineNo: cache ? cache[keyLineNo] : opener[keyLineNo],\n        x: cache ? cache[keyX] : opener[keyX]\n      };\n    }\n  }\n  else if (name === ERROR_UNCLOSED_PAREN) {\n    e.lineNo = opener[keyLineNo];\n    e.x = opener[keyX];\n  }\n  return e;\n}\n\n//------------------------------------------------------------------------------\n// String Operations\n//------------------------------------------------------------------------------\n\nfunction replaceWithinString(orig, start, end, replace) {\n  return (\n    orig.substring(0, start) +\n    replace +\n    orig.substring(end)\n  );\n}\n\nif (RUN_ASSERTS) {\n  console.assert(replaceWithinString('aaa', 0, 2, '') === 'a');\n  console.assert(replaceWithinString('aaa', 0, 1, 'b') === 'baa');\n  console.assert(replaceWithinString('aaa', 0, 2, 'b') === 'ba');\n}\n\nfunction repeatString(text, n) {\n  var i;\n  var result = \"\";\n  for (i = 0; i < n; i++) {\n    result += text;\n  }\n  return result;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(repeatString('a', 2) === 'aa');\n  console.assert(repeatString('aa', 3) === 'aaaaaa');\n  console.assert(repeatString('aa', 0) === '');\n  console.assert(repeatString('', 0) === '');\n  console.assert(repeatString('', 5) === '');\n}\n\nfunction getLineEnding(text) {\n  // NOTE: We assume that if the CR char \"\\r\" is used anywhere,\n  //       then we should use CRLF line-endings after every line.\n  var i = text.search(\"\\r\");\n  if (i !== -1) {\n    return \"\\r\\n\";\n  }\n  return \"\\n\";\n}\n\n//------------------------------------------------------------------------------\n// Line operations\n//------------------------------------------------------------------------------\n\nfunction isCursorAffected(result, start, end) {\n  if (result.cursorX === start &&\n      result.cursorX === end) {\n    return result.cursorX === 0;\n  }\n  return result.cursorX >= end;\n}\n\nfunction shiftCursorOnEdit(result, lineNo, start, end, replace) {\n  var oldLength = end - start;\n  var newLength = replace.length;\n  var dx = newLength - oldLength;\n\n  if (dx !== 0 &&\n      result.cursorLine === lineNo &&\n      result.cursorX !== UINT_NULL &&\n      isCursorAffected(result, start, end)) {\n    result.cursorX += dx;\n  }\n}\n\nfunction replaceWithinLine(result, lineNo, start, end, replace) {\n  var line = result.lines[lineNo];\n  var newLine = replaceWithinString(line, start, end, replace);\n  result.lines[lineNo] = newLine;\n\n  shiftCursorOnEdit(result, lineNo, start, end, replace);\n}\n\nfunction insertWithinLine(result, lineNo, idx, insert) {\n  replaceWithinLine(result, lineNo, idx, idx, insert);\n}\n\nfunction initLine(result) {\n  result.x = 0;\n  result.lineNo++;\n\n  // reset line-specific state\n  result.indentX = UINT_NULL;\n  result.commentX = UINT_NULL;\n  result.indentDelta = 0;\n  delete result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  delete result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n  delete result.errorPosCache[ERROR_LEADING_CLOSE_PAREN];\n\n  result.trackingArgTabStop = null;\n  result.trackingIndent = !result.isInStr;\n}\n\n// if the current character has changed, commit its change to the current line.\nfunction commitChar(result, origCh) {\n  var ch = result.ch;\n  if (origCh !== ch) {\n    replaceWithinLine(result, result.lineNo, result.x, result.x + origCh.length, ch);\n    result.indentDelta -= (origCh.length - ch.length);\n  }\n  result.x += ch.length;\n}\n\n//------------------------------------------------------------------------------\n// Misc Utils\n//------------------------------------------------------------------------------\n\nfunction clamp(val, minN, maxN) {\n  if (minN !== UINT_NULL) {\n    val = Math.max(minN, val);\n  }\n  if (maxN !== UINT_NULL) {\n    val = Math.min(maxN, val);\n  }\n  return val;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(clamp(1, 3, 5) === 3);\n  console.assert(clamp(9, 3, 5) === 5);\n  console.assert(clamp(1, 3, UINT_NULL) === 3);\n  console.assert(clamp(5, 3, UINT_NULL) === 5);\n  console.assert(clamp(1, UINT_NULL, 5) === 1);\n  console.assert(clamp(9, UINT_NULL, 5) === 5);\n  console.assert(clamp(1, UINT_NULL, UINT_NULL) === 1);\n}\n\nfunction peek(arr, idxFromBack) {\n  var maxIdx = arr.length - 1;\n  if (idxFromBack > maxIdx) {\n    return null;\n  }\n  return arr[maxIdx - idxFromBack];\n}\n\nif (RUN_ASSERTS) {\n  console.assert(peek(['a'], 0) === 'a');\n  console.assert(peek(['a'], 1) === null);\n  console.assert(peek(['a', 'b', 'c'], 0) === 'c');\n  console.assert(peek(['a', 'b', 'c'], 1) === 'b');\n  console.assert(peek(['a', 'b', 'c'], 5) === null);\n  console.assert(peek([], 0) === null);\n  console.assert(peek([], 1) === null);\n}\n\n//------------------------------------------------------------------------------\n// Questions about characters\n//------------------------------------------------------------------------------\n\nfunction isOpenParen(ch) {\n  return ch === \"{\" || ch === \"(\" || ch === \"[\";\n}\n\nfunction isCloseParen(ch) {\n  return ch === \"}\" || ch === \")\" || ch === \"]\";\n}\n\nfunction isValidCloseParen(parenStack, ch) {\n  if (parenStack.length === 0) {\n    return false;\n  }\n  return peek(parenStack, 0).ch === MATCH_PAREN[ch];\n}\n\nfunction isWhitespace(result) {\n  var ch = result.ch;\n  return !result.isEscaped && (ch === BLANK_SPACE || ch === DOUBLE_SPACE);\n}\n\n// can this be the last code character of a list?\nfunction isClosable(result) {\n  var ch = result.ch;\n  var closer = (isCloseParen(ch) && !result.isEscaped);\n  return result.isInCode && !isWhitespace(result) && ch !== \"\" && !closer;\n}\n\n//------------------------------------------------------------------------------\n// Advanced operations on characters\n//------------------------------------------------------------------------------\n\nfunction checkCursorHolding(result) {\n  var opener = peek(result.parenStack, 0);\n  var parent = peek(result.parenStack, 1);\n  var holdMinX = parent ? parent.x+1 : 0;\n  var holdMaxX = opener.x;\n\n  var holding = (\n    result.cursorLine === opener.lineNo &&\n    holdMinX <= result.cursorX && result.cursorX <= holdMaxX\n  );\n  var shouldCheckPrev = !result.changes && result.prevCursorLine !== UINT_NULL;\n  if (shouldCheckPrev) {\n    var prevHolding = (\n      result.prevCursorLine === opener.lineNo &&\n      holdMinX <= result.prevCursorX && result.prevCursorX <= holdMaxX\n    );\n    if (prevHolding && !holding) {\n      throw {releaseCursorHold: true};\n    }\n  }\n  return holding;\n}\n\nfunction trackArgTabStop(result, state) {\n  if (state === 'space') {\n    if (result.isInCode && isWhitespace(result)) {\n      result.trackingArgTabStop = 'arg';\n    }\n  }\n  else if (state === 'arg') {\n    if (!isWhitespace(result)) {\n        var opener = peek(result.parenStack, 0);\n        opener.argX = result.x;\n        result.trackingArgTabStop = null;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Literal character events\n//------------------------------------------------------------------------------\n\nfunction onOpenParen(result) {\n  if (result.isInCode) {\n    var opener = {\n      inputLineNo: result.inputLineNo,\n      inputX: result.inputX,\n\n      lineNo: result.lineNo,\n      x: result.x,\n      ch: result.ch,\n      indentDelta: result.indentDelta,\n      maxChildIndent: UINT_NULL\n    };\n\n    if (result.returnParens) {\n      opener.children = [];\n      opener.closer = {\n        lineNo: UINT_NULL,\n        x: UINT_NULL,\n        ch: ''\n      };\n      var parent = peek(result.parenStack, 0);\n      parent = parent ? parent.children : result.parens;\n      parent.push(opener);\n    }\n\n    result.parenStack.push(opener);\n    result.trackingArgTabStop = 'space';\n  }\n}\n\nfunction setCloser(opener, lineNo, x, ch) {\n  opener.closer.lineNo = lineNo;\n  opener.closer.x = x;\n  opener.closer.ch = ch;\n}\n\nfunction onMatchedCloseParen(result) {\n  var opener = peek(result.parenStack, 0);\n  if (result.returnParens) {\n    setCloser(opener, result.lineNo, result.x, result.ch);\n  }\n\n  result.parenTrail.endX = result.x + 1;\n  result.parenTrail.openers.push(opener);\n\n  if (result.mode === INDENT_MODE && result.smart && checkCursorHolding(result)) {\n    var origStartX = result.parenTrail.startX;\n    var origEndX = result.parenTrail.endX;\n    var origOpeners = result.parenTrail.openers;\n    resetParenTrail(result, result.lineNo, result.x+1);\n    result.parenTrail.clamped.startX = origStartX;\n    result.parenTrail.clamped.endX = origEndX;\n    result.parenTrail.clamped.openers = origOpeners;\n  }\n  result.parenStack.pop();\n  result.trackingArgTabStop = null;\n}\n\nfunction onUnmatchedCloseParen(result) {\n  if (result.mode === PAREN_MODE) {\n    var trail = result.parenTrail;\n    var inLeadingParenTrail = trail.lineNo === result.lineNo && trail.startX === result.indentX;\n    var canRemove = result.smart && inLeadingParenTrail;\n    if (!canRemove) {\n      throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    }\n  }\n  else if (result.mode === INDENT_MODE && !result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN]) {\n    cacheErrorPos(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    var opener = peek(result.parenStack, 0);\n    if (opener) {\n      var e = cacheErrorPos(result, ERROR_UNMATCHED_OPEN_PAREN);\n      e.inputLineNo = opener.inputLineNo;\n      e.inputX = opener.inputX;\n    }\n  }\n  result.ch = \"\";\n}\n\nfunction onCloseParen(result) {\n  if (result.isInCode) {\n    if (isValidCloseParen(result.parenStack, result.ch)) {\n      onMatchedCloseParen(result);\n    }\n    else {\n      onUnmatchedCloseParen(result);\n    }\n  }\n}\n\nfunction onTab(result) {\n  if (result.isInCode) {\n    result.ch = DOUBLE_SPACE;\n  }\n}\n\nfunction onSemicolon(result) {\n  if (result.isInCode) {\n    result.isInComment = true;\n    result.commentX = result.x;\n    result.trackingArgTabStop = null;\n  }\n}\n\nfunction onNewline(result) {\n  result.isInComment = false;\n  result.ch = \"\";\n}\n\nfunction onQuote(result) {\n  if (result.isInStr) {\n    result.isInStr = false;\n  }\n  else if (result.isInComment) {\n    result.quoteDanger = !result.quoteDanger;\n    if (result.quoteDanger) {\n      cacheErrorPos(result, ERROR_QUOTE_DANGER);\n    }\n  }\n  else {\n    result.isInStr = true;\n    cacheErrorPos(result, ERROR_UNCLOSED_QUOTE);\n  }\n}\n\nfunction onBackslash(result) {\n  result.isEscaping = true;\n}\n\nfunction afterBackslash(result) {\n  result.isEscaping = false;\n  result.isEscaped = true;\n\n  if (result.ch === NEWLINE) {\n    if (result.isInCode) {\n      throw error(result, ERROR_EOL_BACKSLASH);\n    }\n    onNewline(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Character dispatch\n//------------------------------------------------------------------------------\n\nfunction onChar(result) {\n  var ch = result.ch;\n  result.isEscaped = false;\n\n  if (result.isEscaping)        { afterBackslash(result); }\n  else if (isOpenParen(ch))     { onOpenParen(result); }\n  else if (isCloseParen(ch))    { onCloseParen(result); }\n  else if (ch === DOUBLE_QUOTE) { onQuote(result); }\n  else if (ch === SEMICOLON)    { onSemicolon(result); }\n  else if (ch === BACKSLASH)    { onBackslash(result); }\n  else if (ch === TAB)          { onTab(result); }\n  else if (ch === NEWLINE)      { onNewline(result); }\n\n  ch = result.ch;\n\n  result.isInCode = !result.isInComment && !result.isInStr;\n\n  if (isClosable(result)) {\n    resetParenTrail(result, result.lineNo, result.x+ch.length);\n  }\n\n  var state = result.trackingArgTabStop;\n  if (state) {\n     trackArgTabStop(result, state);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Cursor functions\n//------------------------------------------------------------------------------\n\nfunction isCursorLeftOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX <= x // inclusive since (cursorX = x) implies (x-1 < cursor < x)\n  );\n}\n\nfunction isCursorRightOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX > x\n  );\n}\n\nfunction isCursorInComment(result, cursorX, cursorLine) {\n  return isCursorRightOf(cursorX, cursorLine, result.commentX, result.lineNo);\n}\n\nfunction handleChangeDelta(result) {\n  if (result.changes && (result.smart || result.mode === PAREN_MODE)) {\n    var line = result.changes[result.inputLineNo];\n    if (line) {\n      var change = line[result.inputX];\n      if (change) {\n        result.indentDelta += (change.newEndX - change.oldEndX);\n      }\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Paren Trail functions\n//------------------------------------------------------------------------------\n\nfunction resetParenTrail(result, lineNo, x) {\n  result.parenTrail.lineNo = lineNo;\n  result.parenTrail.startX = x;\n  result.parenTrail.endX = x;\n  result.parenTrail.openers = [];\n  result.parenTrail.clamped.startX = UINT_NULL;\n  result.parenTrail.clamped.endX = UINT_NULL;\n  result.parenTrail.clamped.openers = [];\n}\n\nfunction isCursorClampingParenTrail(result, cursorX, cursorLine) {\n  return (\n    isCursorRightOf(cursorX, cursorLine, result.parenTrail.startX, result.lineNo) &&\n    !isCursorInComment(result, cursorX, cursorLine)\n  );\n}\n\n// INDENT MODE: allow the cursor to clamp the paren trail\nfunction clampParenTrailToCursor(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  var clamping = isCursorClampingParenTrail(result, result.cursorX, result.cursorLine);\n\n  if (clamping) {\n    var newStartX = Math.max(startX, result.cursorX);\n    var newEndX = Math.max(endX, result.cursorX);\n\n    var line = result.lines[result.lineNo];\n    var removeCount = 0;\n    var i;\n    for (i = startX; i < newStartX; i++) {\n      if (isCloseParen(line[i])) {\n        removeCount++;\n      }\n    }\n\n    var openers = result.parenTrail.openers;\n\n    result.parenTrail.openers = openers.slice(removeCount);\n    result.parenTrail.startX = newStartX;\n    result.parenTrail.endX = newEndX;\n\n    result.parenTrail.clamped.openers = openers.slice(0, removeCount);\n    result.parenTrail.clamped.startX = startX;\n    result.parenTrail.clamped.endX = endX;\n  }\n}\n\n// INDENT MODE: pops the paren trail from the stack\nfunction popParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX) {\n    return;\n  }\n\n  var openers = result.parenTrail.openers;\n  while (openers.length !== 0) {\n    result.parenStack.push(openers.pop());\n  }\n}\n\n// Determine which open-paren (if any) on the parenStack should be considered\n// the direct parent of the current line (given its indentation point).\n// This allows Smart Mode to simulate Paren Mode's structure-preserving\n// behavior by adding its `opener.indentDelta` to the current line's indentation.\n// (care must be taken to prevent redundant indentation correction, detailed below)\nfunction getParentOpenerIndex(result, indentX) {\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    var opener = peek(result.parenStack, i);\n\n    var currOutside = (opener.x < indentX);\n\n    var prevIndentX = indentX - result.indentDelta;\n    var prevOutside = (opener.x - opener.indentDelta < prevIndentX);\n\n    var isParent = false;\n\n    if (prevOutside && currOutside) {\n      isParent = true;\n    }\n    else if (!prevOutside && !currOutside) {\n      isParent = false;\n    }\n    else if (prevOutside && !currOutside) {\n      // POSSIBLE FRAGMENTATION\n      // (foo    --\\\n      //            +--- FRAGMENT `(foo bar)` => `(foo) bar`\n      // bar)    --/\n\n      // 1. PREVENT FRAGMENTATION\n      // ```in\n      //   (foo\n      // ++\n      //   bar\n      // ```\n      // ```out\n      //   (foo\n      //     bar\n      // ```\n      if (result.indentDelta === 0) {\n        isParent = true;\n      }\n\n      // 2. ALLOW FRAGMENTATION\n      // ```in\n      // (foo\n      //   bar\n      // --\n      // ```\n      // ```out\n      // (foo)\n      // bar\n      // ```\n      else if (opener.indentDelta === 0) {\n        isParent = false;\n      }\n\n      else {\n        // TODO: identify legitimate cases where both are nonzero\n\n        // allow the fragmentation by default\n        isParent = false;\n\n        // TODO: should we throw to exit instead?  either of:\n        // 1. give up, just `throw error(...)`\n        // 2. fallback to paren mode to preserve structure\n      }\n    }\n    else if (!prevOutside && currOutside) {\n      // POSSIBLE ADOPTION\n      // (foo)   --\\\n      //            +--- ADOPT `(foo) bar` => `(foo bar)`\n      //   bar   --/\n\n      var nextOpener = peek(result.parenStack, i+1);\n\n      // 1. DISALLOW ADOPTION\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar)\n      //   baz)\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // -\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //  (bar)\n      //  baz)\n      // ```\n      if (nextOpener && nextOpener.indentDelta <= opener.indentDelta) {\n        // we can only disallow adoption if nextOpener.indentDelta will actually\n        // prevent the indentX from being in the opener's threshold.\n        if (indentX + nextOpener.indentDelta > opener.x) {\n          isParent = true;\n        }\n        else {\n          isParent = false;\n        }\n      }\n\n      // 2. ALLOW ADOPTION\n      // ```in\n      // (foo\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar\n      //     baz))\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // -\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      //  (foo\n      //   (bar)\n      //    baz)\n      // ```\n      else if (nextOpener && nextOpener.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      // 3. ALLOW ADOPTION\n      // ```in\n      //   (foo)\n      // --\n      //   bar\n      // ```\n      // ```out\n      // (foo\n      //   bar)\n      // ```\n      // OR\n      // ```in\n      // (foo)\n      //   bar\n      // ++\n      // ```\n      // ```out\n      // (foo\n      //   bar\n      // ```\n      // OR\n      // ```in\n      //  (foo)\n      // +\n      //   bar\n      // ++\n      // ```\n      // ```out\n      //  (foo\n      //   bar)\n      // ```\n      else if (result.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      if (isParent) { // if new parent\n        // Clear `indentDelta` since it is reserved for previous child lines only.\n        opener.indentDelta = 0;\n      }\n    }\n\n    if (isParent) {\n      break;\n    }\n  }\n  return i;\n}\n\n// INDENT MODE: correct paren trail from indentation\nfunction correctParenTrail(result, indentX) {\n  var parens = \"\";\n\n  var index = getParentOpenerIndex(result, indentX);\n  var i;\n  for (i=0; i<index; i++) {\n    var opener = result.parenStack.pop();\n    result.parenTrail.openers.push(opener);\n    var closeCh = MATCH_PAREN[opener.ch];\n    parens += closeCh;\n\n    if (result.returnParens) {\n      setCloser(opener, result.parenTrail.lineNo, result.parenTrail.startX+i, closeCh);\n    }\n  }\n\n  if (result.parenTrail.lineNo !== UINT_NULL) {\n    replaceWithinLine(result, result.parenTrail.lineNo, result.parenTrail.startX, result.parenTrail.endX, parens);\n    result.parenTrail.endX = result.parenTrail.startX + parens.length;\n    rememberParenTrail(result);\n  }\n}\n\n// PAREN MODE: remove spaces from the paren trail\nfunction cleanParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX ||\n      result.lineNo !== result.parenTrail.lineNo) {\n    return;\n  }\n\n  var line = result.lines[result.lineNo];\n  var newTrail = \"\";\n  var spaceCount = 0;\n  var i;\n  for (i = startX; i < endX; i++) {\n    if (isCloseParen(line[i])) {\n      newTrail += line[i];\n    }\n    else {\n      spaceCount++;\n    }\n  }\n\n  if (spaceCount > 0) {\n    replaceWithinLine(result, result.lineNo, startX, endX, newTrail);\n    result.parenTrail.endX -= spaceCount;\n  }\n}\n\n// PAREN MODE: append a valid close-paren to the end of the paren trail\nfunction appendParenTrail(result) {\n  var opener = result.parenStack.pop();\n  var closeCh = MATCH_PAREN[opener.ch];\n  if (result.returnParens) {\n    setCloser(opener, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n  }\n\n  setMaxIndent(result, opener);\n  insertWithinLine(result, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n\n  result.parenTrail.endX++;\n  result.parenTrail.openers.push(opener);\n  updateRememberedParenTrail(result);\n}\n\nfunction invalidateParenTrail(result) {\n  result.parenTrail = initialParenTrail();\n}\n\nfunction checkUnmatchedOutsideParenTrail(result) {\n  var cache = result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  if (cache && cache.x < result.parenTrail.startX) {\n    throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n  }\n}\n\nfunction setMaxIndent(result, opener) {\n  if (opener) {\n    var parent = peek(result.parenStack, 0);\n    if (parent) {\n      parent.maxChildIndent = opener.x;\n    }\n    else {\n      result.maxIndent = opener.x;\n    }\n  }\n}\n\nfunction rememberParenTrail(result) {\n  var trail = result.parenTrail;\n  var openers = trail.clamped.openers.concat(trail.openers);\n  if (openers.length > 0) {\n    var isClamped = trail.clamped.startX !== UINT_NULL;\n    var allClamped = trail.openers.length === 0;\n    var shortTrail = {\n      lineNo: trail.lineNo,\n      startX: isClamped ? trail.clamped.startX : trail.startX,\n      endX: allClamped ? trail.clamped.endX : trail.endX\n    };\n    result.parenTrails.push(shortTrail);\n\n    if (result.returnParens) {\n      var i;\n      for (i=0; i<openers.length; i++) {\n        openers[i].closer.trail = shortTrail;\n      }\n    }\n  }\n}\n\nfunction updateRememberedParenTrail(result) {\n  var trail = result.parenTrails[result.parenTrails.length-1];\n  if (!trail || trail.lineNo !== result.parenTrail.lineNo) {\n    rememberParenTrail(result);\n  }\n  else {\n    trail.endX = result.parenTrail.endX;\n    if (result.returnParens) {\n      var opener = result.parenTrail.openers[result.parenTrail.openers.length-1];\n      opener.closer.trail = trail;\n    }\n  }\n}\n\nfunction finishNewParenTrail(result) {\n  if (result.isInStr) {\n    invalidateParenTrail(result);\n  }\n  else if (result.mode === INDENT_MODE) {\n    clampParenTrailToCursor(result);\n    popParenTrail(result);\n  }\n  else if (result.mode === PAREN_MODE) {\n    setMaxIndent(result, peek(result.parenTrail.openers, 0));\n    if (result.lineNo !== result.cursorLine) {\n      cleanParenTrail(result);\n    }\n    rememberParenTrail(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Indentation functions\n//------------------------------------------------------------------------------\n\nfunction addIndent(result, delta) {\n  var origIndent = result.x;\n  var newIndent = origIndent + delta;\n  var indentStr = repeatString(BLANK_SPACE, newIndent);\n  replaceWithinLine(result, result.lineNo, 0, origIndent, indentStr);\n  result.x = newIndent;\n  result.indentX = newIndent;\n  result.indentDelta += delta;\n}\n\nfunction shouldAddOpenerIndent(result, opener) {\n  // Don't add opener.indentDelta if the user already added it.\n  // (happens when multiple lines are indented together)\n  return (opener.indentDelta !== result.indentDelta);\n}\n\nfunction correctIndent(result) {\n  var origIndent = result.x;\n  var newIndent = origIndent;\n  var minIndent = 0;\n  var maxIndent = result.maxIndent;\n\n  var opener = peek(result.parenStack, 0);\n  if (opener) {\n    minIndent = opener.x + 1;\n    maxIndent = opener.maxChildIndent;\n    if (shouldAddOpenerIndent(result, opener)) {\n      newIndent += opener.indentDelta;\n    }\n  }\n\n  newIndent = clamp(newIndent, minIndent, maxIndent);\n\n  if (newIndent !== origIndent) {\n    addIndent(result, newIndent - origIndent);\n  }\n}\n\nfunction onIndent(result) {\n  result.indentX = result.x;\n  result.trackingIndent = false;\n\n  if (result.quoteDanger) {\n    throw error(result, ERROR_QUOTE_DANGER);\n  }\n\n  if (result.mode === INDENT_MODE) {\n\n    correctParenTrail(result, result.x);\n\n    var opener = peek(result.parenStack, 0);\n    if (opener && shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n  }\n  else if (result.mode === PAREN_MODE) {\n    correctIndent(result);\n  }\n}\n\nfunction checkLeadingCloseParen(result) {\n  if (result.errorPosCache[ERROR_LEADING_CLOSE_PAREN] &&\n      result.parenTrail.lineNo === result.lineNo) {\n    throw error(result, ERROR_LEADING_CLOSE_PAREN);\n  }\n}\n\nfunction onLeadingCloseParen(result) {\n  if (result.mode === INDENT_MODE) {\n    if (!result.forceBalance) {\n      if (result.smart) {\n        throw {leadingCloseParen: true};\n      }\n      if (!result.errorPosCache[ERROR_LEADING_CLOSE_PAREN]) {\n        cacheErrorPos(result, ERROR_LEADING_CLOSE_PAREN);\n      }\n    }\n    result.skipChar = true;\n  }\n  if (result.mode === PAREN_MODE) {\n    if (!isValidCloseParen(result.parenStack, result.ch)) {\n      if (result.smart) {\n        result.skipChar = true;\n      }\n      else {\n        throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n      }\n    }\n    else if (isCursorLeftOf(result.cursorX, result.cursorLine, result.x, result.lineNo)) {\n      resetParenTrail(result, result.lineNo, result.x);\n      onIndent(result);\n    }\n    else {\n      appendParenTrail(result);\n      result.skipChar = true;\n    }\n  }\n}\n\nfunction onCommentLine(result) {\n  var parenTrailLength = result.parenTrail.openers.length;\n\n  // restore the openers matching the previous paren trail\n  var j;\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.push(peek(result.parenTrail.openers, j));\n    }\n  }\n\n  var i = getParentOpenerIndex(result, result.x);\n  var opener = peek(result.parenStack, i);\n  if (opener) {\n    // shift the comment line based on the parent open paren\n    if (shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n    // TODO: store some information here if we need to place close-parens after comment lines\n  }\n\n  // repop the openers matching the previous paren trail\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.pop();\n    }\n  }\n}\n\nfunction checkIndent(result) {\n  if (isCloseParen(result.ch)) {\n    onLeadingCloseParen(result);\n  }\n  else if (result.ch === SEMICOLON) {\n    // comments don't count as indentation points\n    onCommentLine(result);\n    result.trackingIndent = false;\n  }\n  else if (result.ch !== NEWLINE &&\n           result.ch !== BLANK_SPACE &&\n           result.ch !== TAB) {\n    onIndent(result);\n  }\n}\n\nfunction makeTabStop(result, opener) {\n  var tabStop = {\n    ch: opener.ch,\n    x: opener.x,\n    lineNo: opener.lineNo\n  };\n  if (opener.argX != null) {\n    tabStop.argX = opener.argX;\n  }\n  return tabStop;\n}\n\nfunction getTabStopLine(result) {\n  return result.selectionStartLine !== UINT_NULL ? result.selectionStartLine : result.cursorLine;\n}\n\nfunction setTabStops(result) {\n  if (getTabStopLine(result) !== result.lineNo) {\n    return;\n  }\n\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    result.tabStops.push(makeTabStop(result, result.parenStack[i]));\n  }\n\n  if (result.mode === PAREN_MODE) {\n    for (i=result.parenTrail.openers.length-1; i>=0; i--) {\n      result.tabStops.push(makeTabStop(result, result.parenTrail.openers[i]));\n    }\n  }\n\n  // remove argX if it falls to the right of the next stop\n  for (i=1; i<result.tabStops.length; i++) {\n    var x = result.tabStops[i].x;\n    var prevArgX = result.tabStops[i-1].argX;\n    if (prevArgX != null && prevArgX >= x) {\n      delete result.tabStops[i-1].argX;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// High-level processing functions\n//------------------------------------------------------------------------------\n\nfunction processChar(result, ch) {\n  var origCh = ch;\n\n  result.ch = ch;\n  result.skipChar = false;\n\n  handleChangeDelta(result);\n\n  if (result.trackingIndent) {\n    checkIndent(result);\n  }\n\n  if (result.skipChar) {\n    result.ch = \"\";\n  }\n  else {\n    onChar(result);\n  }\n\n  commitChar(result, origCh);\n}\n\nfunction processLine(result, lineNo) {\n  initLine(result);\n  result.lines.push(result.inputLines[lineNo]);\n\n  setTabStops(result);\n\n  var x;\n  for (x = 0; x < result.inputLines[lineNo].length; x++) {\n    result.inputX = x;\n    processChar(result, result.inputLines[lineNo][x]);\n  }\n  processChar(result, NEWLINE);\n\n  if (!result.forceBalance) {\n    checkUnmatchedOutsideParenTrail(result);\n    checkLeadingCloseParen(result);\n  }\n\n  if (result.lineNo === result.parenTrail.lineNo) {\n    finishNewParenTrail(result);\n  }\n}\n\nfunction finalizeResult(result) {\n  if (result.quoteDanger) { throw error(result, ERROR_QUOTE_DANGER); }\n  if (result.isInStr)     { throw error(result, ERROR_UNCLOSED_QUOTE); }\n\n  if (result.parenStack.length !== 0) {\n    if (result.mode === PAREN_MODE) {\n      throw error(result, ERROR_UNCLOSED_PAREN);\n    }\n  }\n  if (result.mode === INDENT_MODE) {\n    initLine(result);\n    onIndent(result);\n  }\n  result.success = true;\n}\n\nfunction processError(result, e) {\n  result.success = false;\n  if (e.parinferError) {\n    delete e.parinferError;\n    result.error = e;\n  }\n  else {\n    result.error.name = ERROR_UNHANDLED;\n    result.error.message = e.stack;\n    throw e;\n  }\n}\n\nfunction processText(text, options, mode, smart) {\n  var result = getInitialResult(text, options, mode, smart);\n\n  try {\n    var i;\n    for (i = 0; i < result.inputLines.length; i++) {\n      result.inputLineNo = i;\n      processLine(result, i);\n    }\n    finalizeResult(result);\n  }\n  catch (e) {\n    if (e.leadingCloseParen || e.releaseCursorHold) {\n      return processText(text, options, PAREN_MODE, smart);\n    }\n    processError(result, e);\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nfunction publicResult(result) {\n  var lineEnding = getLineEnding(result.origText);\n  var final;\n  if (result.success) {\n    final = {\n      text: result.lines.join(lineEnding),\n      cursorX: result.cursorX,\n      cursorLine: result.cursorLine,\n      success: true,\n      tabStops: result.tabStops,\n      parenTrails: result.parenTrails\n    };\n    if (result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  else {\n    final = {\n      text: result.partialResult ? result.lines.join(lineEnding) : result.origText,\n      cursorX: result.partialResult ? result.cursorX : result.origCursorX,\n      cursorLine: result.partialResult ? result.cursorLine : result.origCursorLine,\n      parenTrails: result.partialResult ? result.parenTrails : null,\n      success: false,\n      error: result.error\n    };\n    if (result.partialResult && result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  if (final.cursorX === UINT_NULL) { delete final.cursorX; }\n  if (final.cursorLine === UINT_NULL) { delete final.cursorLine; }\n  if (final.tabStops && final.tabStops.length === 0) { delete final.tabStops; }\n  return final;\n}\n\nfunction indentMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, INDENT_MODE));\n}\n\nfunction parenMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, PAREN_MODE));\n}\n\nfunction smartMode(text, options) {\n  options = parseOptions(options);\n  var smart = options.selectionStartLine == null;\n  return publicResult(processText(text, options, INDENT_MODE, smart));\n}\n\nvar API = {\n  version: \"3.12.0\",\n  indentMode: indentMode,\n  parenMode: parenMode,\n  smartMode: smartMode\n};\n\nreturn API;\n\n})); // end module anonymous scope\n\n};"],
"names":["shadow$provide","global","require","module","exports","root","factory","define","amd","parinfer","isInteger","x","isFinite","Math","floor","parseOptions","options","cursorX","cursorLine","prevCursorX","prevCursorLine","selectionStartLine","changes","partialResult","forceBalance","returnParens","initialParenTrail","lineNo","UINT_NULL","startX","endX","openers","clamped","cacheErrorPos","result","errorName","e","inputLineNo","inputX","errorPosCache","error","name","cache","keyLineNo","keyX","parinferError","message","errorMessages","opener","peek","parenStack","ERROR_UNMATCHED_CLOSE_PAREN","ERROR_UNMATCHED_OPEN_PAREN","extra","ERROR_UNCLOSED_PAREN","replaceWithinLine","start","end","replace","line","lines","orig","substring","newLine","dx","length","initLine","indentX","commentX","indentDelta","ERROR_LEADING_CLOSE_PAREN","trackingArgTabStop","trackingIndent","isInStr","arr","idxFromBack","maxIdx","isCloseParen","ch","isValidCloseParen","MATCH_PAREN","isWhitespace","isEscaped","BLANK_SPACE","DOUBLE_SPACE","isCursorRightOf","resetParenTrail","parenTrail","getParentOpenerIndex","i","currOutside","prevOutside","isParent","nextOpener","setMaxIndent","parent","maxChildIndent","maxIndent","rememberParenTrail","trail","concat","shortTrail","parenTrails","push","closer","addIndent","delta","origIndent","newIndent","onIndent","quoteDanger","ERROR_QUOTE_DANGER","INDENT_MODE","mode","parens","index","pop","closeCh","PAREN_MODE","minIndent","val","max","min","makeTabStop","tabStop","argX","processChar","skipChar","smart","change","newEndX","oldEndX","leadingCloseParen","idx","SEMICOLON","parenTrailLength","j","NEWLINE","TAB","isEscaping","isInCode","ERROR_EOL_BACKSLASH","isInComment","children","holdMinX","holdMaxX","holding","releaseCursorHold","origStartX","origEndX","origOpeners","canRemove","inLeadingParenTrail","DOUBLE_QUOTE","ERROR_UNCLOSED_QUOTE","BACKSLASH","state","processText","text","origText","origCursorX","origCursorLine","inputLines","split","LINE_ENDING_REGEX","tabStops","success","Array","isArray","newLines","newText","oldLines","oldText","newEndLineNo","lookupLineNo","lookupX","prevArgX","newStartX","removeCount","slice","newTrail","spaceCount","ERROR_UNHANDLED","stack","publicResult","search","final","join","lineEnding","API","version","indentMode","parenMode","smartMode"]
}

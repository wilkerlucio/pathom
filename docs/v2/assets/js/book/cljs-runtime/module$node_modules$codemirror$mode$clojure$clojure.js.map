{
"version":3,
"file":"module$node_modules$codemirror$mode$clojure$clojure.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/codemirror/mode/clojure/clojure.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$codemirror$mode$clojure$clojure\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Hans Engel\n * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"variable\";\n    var INDENT_WORD_SKIP = options.indentUnit || 2;\n    var NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var atoms = makeKeywords(\"true false nil\");\n\n    var keywords = makeKeywords(\n      \"defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest \" +\n      \"slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn \" +\n      \"do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync \" +\n      \"doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars \" +\n      \"binding gen-class gen-and-load-class gen-and-save-class handler-case handle\");\n\n    var builtins = makeKeywords(\n        \"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* \" +\n        \"*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* \" +\n        \"*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* \" +\n        \"*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> \" +\n        \"->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor \" +\n        \"aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! \" +\n        \"alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double \" +\n        \"aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 \" +\n        \"bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set \" +\n        \"bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast \" +\n        \"byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append \" +\n        \"chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors \" +\n        \"clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond condp \" +\n        \"conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? \" +\n        \"declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol \" +\n        \"defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc \" +\n        \"dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last \" +\n        \"drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info \" +\n        \"extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword \" +\n        \"find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? \" +\n        \"fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? \" +\n        \"gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash \" +\n        \"hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? \" +\n        \"int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep \" +\n        \"keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file \" +\n        \"load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array \" +\n        \"make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods \" +\n        \"min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty \" +\n        \"not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias \" +\n        \"ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all \" +\n        \"partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers \" +\n        \"primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str \" +\n        \"prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues \" +\n        \"quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern \" +\n        \"re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history \" +\n        \"ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods \" +\n        \"remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest \" +\n        \"restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? \" +\n        \"seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts \" +\n        \"shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? \" +\n        \"special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol \" +\n        \"symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce \" +\n        \"transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec \" +\n        \"unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int \" +\n        \"unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int \"+\n        \"unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote \" +\n        \"unquote-splicing update update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of \" +\n        \"vector? volatile! volatile? vreset! vswap! when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context \" +\n        \"with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap \" +\n        \"*default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! \" +\n        \"set-agent-send-off-executor! some-> some->>\");\n\n    var indentKeys = makeKeywords(\n        // Built-ins\n        \"ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto \" +\n        \"locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type \" +\n        \"try catch \" +\n\n        // Binding forms\n        \"let letfn binding loop for doseq dotimes when-let if-let \" +\n\n        // Data structures\n        \"defstruct struct-map assoc \" +\n\n        // clojure.test\n        \"testing deftest \" +\n\n        // contrib\n        \"handler-case handle dotrace deftrace\");\n\n    var tests = {\n        digit: /\\d/,\n        digit_or_colon: /[\\d:]/,\n        hex: /[0-9a-f]/i,\n        sign: /[+-]/,\n        exponent: /e/i,\n        keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n        symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/,\n        block_indent: /^(?:def|with)[^\\/]+$|\\/(?:def|with)/\n    };\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    function isNumber(ch, stream){\n        // hex\n        if ( ch === '0' && stream.eat(/x/i) ) {\n            stream.eatWhile(tests.hex);\n            return true;\n        }\n\n        // leading sign\n        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n          stream.eat(tests.sign);\n          ch = stream.next();\n        }\n\n        if ( tests.digit.test(ch) ) {\n            stream.eat(ch);\n            stream.eatWhile(tests.digit);\n\n            if ( '.' == stream.peek() ) {\n                stream.eat('.');\n                stream.eatWhile(tests.digit);\n            } else if ('/' == stream.peek() ) {\n                stream.eat('/');\n                stream.eatWhile(tests.digit);\n            }\n\n            if ( stream.eat(tests.exponent) ) {\n                stream.eat(tests.sign);\n                stream.eatWhile(tests.digit);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n        var first = stream.next();\n        // Read special literals: backspace, newline, space, return.\n        // Just read all lowercase letters.\n        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n            return;\n        }\n        // Read unicode character: \\u1000 \\uA0a1\n        if (first === \"u\") {\n            stream.match(/[0-9a-z]{4}/i, true);\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (state.mode != \"string\" && stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in string mode\n                    break;\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n                    } else if (ch == \"\\\\\") {\n                        eatCharacter(stream);\n                        returnType = CHARACTER;\n                    } else if (ch == \"'\" && !( tests.digit_or_colon.test(stream.peek()) )) {\n                        returnType = ATOM;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (isNumber(ch,stream)){\n                        returnType = NUMBER;\n                    } else if (ch == \"(\" || ch == \"[\" || ch == \"{\" ) {\n                        var keyWord = '', indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        if (ch == \"(\") while ((letter = stream.eat(tests.keyword_char)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||\n                                                   tests.block_indent.test(keyWord))) { // indent-word\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation the user defined spaces after\n                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\" || ch == \"}\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : (ch == \"]\" ? \"[\" :\"{\"))) {\n                            popStack(state);\n                        }\n                    } else if ( ch == \":\" ) {\n                        stream.eatWhile(tests.symbol);\n                        return ATOM;\n                    } else {\n                        stream.eatWhile(tests.symbol);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = KEYWORD;\n                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {\n                            returnType = ATOM;\n                        } else {\n                          returnType = VAR;\n                        }\n                    }\n            }\n\n            return returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\nCodeMirror.defineMIME(\"text/x-clojurescript\", \"clojure\");\nCodeMirror.defineMIME(\"application/edn\", \"clojure\");\n\n});\n\n};"],
"names":["shadow$provide","global","require","module","exports","mod","define","amd","CodeMirror","defineMode","options","makeKeywords","str","obj","words","split","i","length","stateStack","indent","type","prev","INDENT_WORD_SKIP","indentUnit","NORMAL_INDENT_UNIT","atoms","keywords","builtins","indentKeys","startState","indentStack","indentation","mode","token","stream","state","sol","eatSpace","next","escaped","returnType","STRING","ch","first","match","CHARACTER","digit_or_colon","test","peek","skipToEnd","COMMENT","eat","eatWhile","hex","digit","sign","exponent","NUMBER","keyWord","indentTemp","column","letter","keyword_char","propertyIsEnumerable","block_indent","eol","current","backUp","BRACKET","symbol","ATOM","KEYWORD","BUILTIN","VAR","closeBrackets","pairs","lineComment","defineMIME"]
}
